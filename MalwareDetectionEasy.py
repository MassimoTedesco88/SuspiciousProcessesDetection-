#Progetto INFO PC - creato il 01.06.2025  - progetto di Massimo S.
#1. raccoglie i dati delle risorse disponibili, e una volta raccolti analizza quali processi utilizzano maggior risorse
#2. Utile per riconoscere quale processo utilizza maggiormente la CPU e la RAM
#3. Calcola HASH SHA-256 dell'eseguibile ( utile per individuare malware camuffati )
#4. Salva i risultati dell'analisi in .log e .csv in una cartella dedicata
#5. Confronto Hash con lista di malware noti, 
#   Scaricata dal sito affidabile https://bazaar.abuse.ch/export/txt/sha256/full
#   (file da scaricare,rinominare listaHashMaligni.txt  nella cartella home/RegistriProcessi)
#6. Diagnostica semplice: dall'analisi ottengo il processo che utilizza più RAM e più CPU, ottenendo il percorso del file e data/ora dell'avvio del processo
#   -Esempi quando utilizzare il programma = Se il PC rallenta a causa di qualche programma , identifico il colpevole
#   -La funzione più importante è la scansione di tutti i processi, che trova il programma malevolo!

import hashlib
import platform
import os
from pathlib import Path #path management
import psutil #processi
from datetime import datetime,timedelta #date, time
import csv

############Costanti - creazione nome cartelle e file
registri=Path.home() / "RegistriProcessi"
cartella_log=registri / "log_processi"
file_log=cartella_log / "processi.log"
file_csv=cartella_log / "tutti_processi.csv"
file_csv2=cartella_log / "tutti_processi_attivi.csv"
file_hash_maligni=cartella_log / "listaHashMaligni.txt" # in realtà scarichiamo manualmente il file .txt e lo rinominiamo così
#######creazione cartella se non esiste
os.makedirs(cartella_log,exist_ok=True)
####ANALISI PROCESSI
def processoPiuRam():
    infoProcesso=None
    tutti_processi=[]

    max_mem=0
    processo_top=None
    processi = psutil.process_iter(['pid','name','memory_info'])
    for proc in processi:
        try:
            mem= proc.info['memory_info'].rss
            if mem > max_mem:
                processo_top= proc
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue
    if processo_top:
        proc_pid=processo_top.pid
        proc_nome=processo_top.name()
        proc_memused=max_mem/(1024**2)
    path=pathprocesso(processo_top)
    start_time=dataavvioProcesso(processo_top)
    if path != "Percorso non disponibile"  :
        hashValue=calcolaHash(path)
    else:
        hashValue="N/D"
    #SALVA NELLA LISTA per LOG
    infoProcesso={
        "PID":proc_pid,
        "Name":proc_nome,
        "MemUsed":proc_memused,
        "Path":path,
        "Start_Time":start_time,
        "SHA256":hashValue
    }
    

    #SALVA NELLA LISTA per CSV
    tutti_processi.append({
        "PID":proc_pid,
        "Name":proc_nome,                
        "Path":path,
        "Start_Time":start_time,
        "SHA256":hashValue
    })
    #salva il csv e il log
    salvaCSV(tutti_processi)
    scriviLog("Processo con più RAM",infoProcesso)
    
    return proc_memused,proc_nome,proc_pid,path,start_time,hashValue
def processoPiuCpu():
    infoProcesso=None
    tutti_processi=[]
    max_cpu=0
    processo_top=None
    processi = psutil.process_iter(['pid','name','memory_info'])
    for proc in processi:
        try:
            cpu= proc.cpu_percent(interval=0.1)
            if cpu > max_cpu:
                max_cpu=cpu
                processo_top= proc
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue
    if processo_top:
        proc_pid=processo_top.pid
        proc_nome=processo_top.name()
        proc_cpuused=max_cpu
    #Percorso file
    path=pathprocesso(processo_top)
    #Avvio processo
    start_time=dataavvioProcesso(processo_top)
    #Calcolo HASH
    if path != "Percorso non disponibile"  :
        hashValue=calcolaHash(path)
    else:
        hashValue="N/D"
    #SALVA NELLA LISTA per LOG
    infoProcesso={
        "PID":proc_pid,
        "Name":proc_nome,
        "CPU%":proc_cpuused,
        "Path":path,
        "Start_Time":start_time,
        "SHA256":hashValue
    }
    #SALVA NELLA LISTA per CSV
    tutti_processi.append({
        "PID":proc_pid,
        "Name":proc_nome,                
        "Path":path,
        "Start_Time":start_time,
        "SHA256":hashValue
    })
    #salva il csv e il log
    salvaCSV(tutti_processi)    
    scriviLog("Processo con più CPU",infoProcesso)
    return proc_cpuused,proc_nome,proc_pid,path,start_time,hashValue

#####INFO RISORSE DEL SISTEMA
def get_cpu_info():
    freq=psutil.cpu_freq()
    cpu=platform.processor()
    arch=platform.machine()
    nCoreFisici=psutil.cpu_count(logical=False)
    nCoreLogici=psutil.cpu_count(logical=True)
    percCpuUsed=psutil.cpu_percent(interval=1)      
    return cpu,arch,nCoreFisici,nCoreLogici,percCpuUsed,freq
def get_system_info():
    return platform.platform()
def get_disk_info():
    st = os.statvfs('/')
    total = (st.f_blocks * st.f_frsize)/(1024**3)
    return f"{total:.2f} GB"
def get_RAM_info():
    return psutil.virtual_memory()

#####FUNZIONI OTTIMIZZAZIONE ANALISI
def pathprocesso(processo_top):
    if processo_top:
        try:
            path=processo_top.exe()
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            path="Percorso non disponibile"
    return path
def dataavvioProcesso(processo_top):
    try:
        start_time=datetime.fromtimestamp(processo_top.create_time()).strftime('%Y-%m-%d %H:%M:%S')#fromtimestamp converte un timestamp UNIX in un oggetto datetime in Python
    except:
        start_time ="N/D"

    return start_time
def calcolaHash(path):
    try:
        with open(path, "rb") as f:
            sha256 = hashlib.sha256()#crea un oggetto hash sha256
            while chunk := f.read(8192):#permette di assegnare e verificare un valore nella stessa riga, leggi 8192byte dal file , assegna il risultato alla variabile chunk
                sha256.update(chunk)# se chunk non è vuoto esegui il blocco, se il file è finito esce dal ciclo
            return sha256.hexdigest()#hash finale sotto forma di stringa esadecimale
    except Exception as e:
        return f"Errore nel calcolo hash: {e}"

#########SALVATTAGGIO SU FILE
def scriviLog(titolo,info_dict):# semplice salvattagio in file.log
    with open(file_log, "a", encoding="utf-8") as f:
        f.write(f"\n==={titolo}===\n")
        for k,v in info_dict.items():
            f.write(f"{k}: {v}\n")
def salvaCSV(lista_processi):# inserisce nella lista solo i processi con maggior consumo di risorse
    intestazioni = ["PID","Name","Path","Start_Time","SHA256","Sospetto"]
    with open(file_csv, "a", newline="",encoding="utf-8")as f:
        writer=csv.DictWriter(f,fieldnames=intestazioni)
        writer.writeheader()
        writer.writerows(lista_processi)

def salvaCSV2(lista_processi): #crea file csv per la lista di tutti i processi in esecuzione e confrontati con la lista hash malware
    intestazioni = ["PID","Name","Path","Start_Time","SHA256","Sospetto"]
    with open(file_csv2, "w", newline="",encoding="utf-8")as f:
        writer=csv.DictWriter(f,fieldnames=intestazioni)
        writer.writeheader()
        writer.writerows(lista_processi)
#######UTILITA'

##########CONTROLLO HASH MALIGNI 

def caricaHashDaFile(filepath=file_hash_maligni): #carica il file della lista hash maligni
    try:
        with open(filepath,"r", encoding="utf-8")as f:
            return set(line.strip().lower() for line in f if line.strip())#.strip() rimuove spazi bianchi e caratteri speciali
    except FileNotFoundError:
        print("File hash non trovato")
        return set()
        
###### Esecuzione delle funzioni 
def operazioni(inputUtente,file_hash_maligni):
    tutti_processi_pc=[]
    cpu,arch,nCoreFisici,nCoreLogici,percCpuUsed,freq =get_cpu_info()
    sistemaOperativo=get_system_info()
    discototale=get_disk_info()
    ram=get_RAM_info()
    ramTotale=ram.total/(1024**3)
    ramDisponibile=ram.available/(1024**3)
    ramUsata=ram.used/(1024**3)
    ramPercUsata=ram.percent

    match inputUtente:
        case "1":
            print("<<<<<<<<<<Analisi Processi che utilizzano maggior risorse:>>>>>>>>>>\n")
            proc_memused,proc_nome,proc_pid,path,start_time,hashValue=processoPiuRam()
            proc_cpuused,proc_nome2,proc_pid2,path2,start_time2,hashValue2=processoPiuCpu()
            print(f"""
>>>> Processo che usa più RAM
pid: {proc_pid}  +  Nome processo: { proc_nome}   + memoria usata {proc_memused:.2f}
path: {path}
data e ora dell'avvio del processo: {start_time}
SHA256: {hashValue}
>>>>>>Processo che usa più CPU
pid: {proc_pid2}  +  Nome processo: { proc_nome2}   + CPU usato {proc_cpuused:.2f} %
path: {path2}
data e ora dell'avvio del processo: {start_time2}
SHA256: {hashValue2}
            
            """)
        
        case "2":
            print("<<<<<<<Risorse del sistema disponibili>>>>>>>>\n")
            print(f"""
CPU = {cpu} |  Archittetura =  {arch } | N.Core Fisici {nCoreFisici} | N Core Logici {nCoreLogici} | % CPU Usata {percCpuUsed:.2f}
Frequenza MHz= {freq} 
S.O. = {sistemaOperativo}
Disco Totale = {discototale}
RAM totale = {ramTotale:.2f} GB | RAM disponbile = {ramDisponibile:.2f} GB
RAM usata = {ramUsata:.2f} GB | {ramPercUsata} %
            
            
            """)
        case "3":
            print("<<<<<< SCANSIONE DI TUTTI I PROCESSI >>>>>>>>>>>>>")          
                        
            hashMaligni=caricaHashDaFile(file_hash_maligni)
            print("Lista degli Hash maligni caricati\n")
            for proc in psutil.process_iter(['pid','name','exe']):
                try:
                    pid=proc.info['pid']
                    name=proc.info['name']
                    percorso=proc.info['exe']
                    if percorso and os.path.isfile(percorso):
                        hash_proc=calcolaHash(percorso)
                        if hash_proc:
                            if hash_proc.lower() in hashMaligni:
                                sospetto='SI'
                                print(f"pid: {pid} - nome: {name} - path: {percorso} - file sospetto")

                                 #SALVA NELLA LISTA per CSV
    
                            else:
                                sospetto='NO'  
                        tutti_processi_pc.append({
                            "PID":pid,
                            "Name":name,                
                            "Path":percorso,                            
                            "SHA256":hash_proc,
                            "Sospetto":sospetto
                        })                              
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
                
                #salva il csv
                salvaCSV2(tutti_processi_pc)
            
        case "4":
            print("Fine del programma!")
            
        case "_":
            print("Non definito")       

def main():
    print(f"""--------------------------
---------------------------------------------------------------
PROGRAMMA SEMPLICE DI ANALISI DELLE RISORSE DEL SISTEMA
----------------------------------------------------------------
---------------------------------------------\n""")
    inputUtente=input("Digita 1 - Analisi Processi con il maggior consumo, 2 - Info Risorse PC, 3 - Controllo Sicurezza dei Processi 4 - Esci\n")
   
    operazioni(inputUtente,file_hash_maligni)  
   

if __name__ == "__main__":
    main()
    
